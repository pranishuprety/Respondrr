# Database Schema

## Execute Raw SQL Function

```sql
create or replace function public.execute_raw_sql(sql text)
returns table (result jsonb) as $$
declare
  result_row record;
begin
  for result_row in execute sql loop
    return query select row_to_json(result_row)::jsonb;
  end loop;
end;
$$ language plpgsql;
```

## Health Metrics Analysis Function

```sql
create or replace function public.get_health_metrics(p_email text)
returns table (
  metric_name text,
  last_hour_current numeric,
  last_hour_current_ts timestamptz,
  last_hour_avg numeric,
  last_hour_low numeric,
  last_hour_high numeric,
  today_avg numeric,
  today_low numeric,
  today_high numeric
) as $$
with params as (
  select
    p_email::text as email,
    now() - interval '1 hour' as hour_start,
    now() as hour_end,
    date_trunc('day', now()) as day_start,
    date_trunc('day', now()) + interval '1 day' as day_end
),

all_metrics as (
  select
    'realtime'::text as source_table,
    case
      when hr.metric_name in ('heartRate','heart_rate') then 'heart_rate'
      when hr.metric_name in ('respiratoryRate','respiratory_rate') then 'respiratory_rate'
      when hr.metric_name in ('activeEnergy','active_energy','activeEnergyBurned') then 'active_energy'
      when hr.metric_name in ('oxygenSaturation','blood_oxygen_saturation') then 'blood_oxygen_saturation'
      else hr.metric_name
    end as metric_name,
    hr.value,
    hr."timestamp"
  from public.health_realtime hr, params p
  where hr.email = p.email
    and hr."timestamp" >= p.day_start
    and hr."timestamp" <  p.day_end

  union all

  select
    'aggregated'::text as source_table,
    ha.metric_name,
    ha.value,
    ha."timestamp"
  from public.health_aggregated ha, params p
  where ha.email = p.email
    and ha."timestamp" >= p.day_start
    and ha."timestamp" <  p.day_end
),

today_stats as (
  select metric_name, avg(value) today_avg, min(value) today_low, max(value) today_high
  from all_metrics
  where metric_name in (
    'heart_rate','respiratory_rate','active_energy',
    'apple_sleeping_wrist_temperature','blood_oxygen_saturation',
    'heart_rate_variability','resting_heart_rate'
  )
  group by metric_name
),

last_hour_base as (
  select *
  from all_metrics, params p
  where "timestamp" >= p.hour_start
    and "timestamp" <= p.hour_end
),

last_hour_stats as (
  select metric_name, avg(value) last_hour_avg, min(value) last_hour_low, max(value) last_hour_high
  from last_hour_base
  group by metric_name
),

last_hour_latest as (
  select distinct on (metric_name)
    metric_name,
    value as last_hour_current,
    "timestamp" as last_hour_current_ts
  from last_hour_base
  order by metric_name, "timestamp" desc
)

select
  t.metric_name,
  l.last_hour_current,
  l.last_hour_current_ts,
  hs.last_hour_avg,
  hs.last_hour_low,
  hs.last_hour_high,
  t.today_avg,
  t.today_low,
  t.today_high
from today_stats t
left join last_hour_stats hs using (metric_name)
left join last_hour_latest l using (metric_name)
order by t.metric_name;
$$ language sql stable;
```

## Alerts Table

```sql
create table if not exists public.alerts (
  id bigint generated by default as identity primary key,
  -- patient this alert belongs to
  patient_id uuid not null references public.profiles(id) on delete cascade,
  patient_email text not null,
  -- alert content
  title text not null,
  message text not null,
  alert_type text not null default 'general',
  severity text not null default 'info',
  status text not null default 'open',
  -- doctor-side acknowledgement (optional)
  acknowledged_by uuid null references public.profiles(id),
  acknowledged_at timestamptz null,
  -- optional metadata (metric name/value, thresholds, source, etc.)
  metadata jsonb not null default '{}'::jsonb,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  constraint alerts_alert_type_check
    check (alert_type in ('general','health_metric','medication','appointment','system')),
  constraint alerts_severity_check
    check (severity in ('info','low','medium','high','critical')),
  constraint alerts_status_check
    check (status in ('open','acknowledged','resolved','dismissed'))
);

create index if not exists alerts_patient_created_idx
  on public.alerts(patient_id, created_at desc);
create index if not exists alerts_status_idx
  on public.alerts(status);
create index if not exists alerts_severity_idx
  on public.alerts(severity);

create or replace function public.update_alerts_updated_at()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

drop trigger if exists set_alerts_updated_at on public.alerts;
create trigger set_alerts_updated_at
before update on public.alerts
for each row
execute function public.update_alerts_updated_at();
```

## Alerts Table RLS Policies

```sql
alter table public.alerts enable row level security;

create policy "Users can view their own alerts"
on public.alerts
for select
using (
  auth.uid() = patient_id
);

create policy "Doctors can view their patients' alerts"
on public.alerts
for select
using (
  exists (
    select 1 from public.patient_doctor_links
    where patient_doctor_links.doctor_id = auth.uid()
    and patient_doctor_links.patient_id = alerts.patient_id
    and patient_doctor_links.status = 'active'
  )
);

create policy "Doctors can acknowledge their patients' alerts"
on public.alerts
for update
using (
  exists (
    select 1 from public.patient_doctor_links
    where patient_doctor_links.doctor_id = auth.uid()
    and patient_doctor_links.patient_id = alerts.patient_id
    and patient_doctor_links.status = 'active'
  )
)
with check (
  exists (
    select 1 from public.patient_doctor_links
    where patient_doctor_links.doctor_id = auth.uid()
    and patient_doctor_links.patient_id = alerts.patient_id
    and patient_doctor_links.status = 'active'
  )
);
```
