# Database Schema

## Alerts Table

```sql
create table if not exists public.alerts (
  id bigint generated by default as identity primary key,
  -- patient this alert belongs to
  patient_id uuid not null references public.profiles(id) on delete cascade,
  patient_email text not null,
  -- alert content
  title text not null,
  message text not null,
  alert_type text not null default 'general',
  severity text not null default 'info',
  status text not null default 'open',
  -- doctor-side acknowledgement (optional)
  acknowledged_by uuid null references public.profiles(id),
  acknowledged_at timestamptz null,
  -- optional metadata (metric name/value, thresholds, source, etc.)
  metadata jsonb not null default '{}'::jsonb,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  constraint alerts_alert_type_check
    check (alert_type in ('general','health_metric','medication','appointment','system')),
  constraint alerts_severity_check
    check (severity in ('info','low','medium','high','critical')),
  constraint alerts_status_check
    check (status in ('open','acknowledged','resolved','dismissed'))
);

create index if not exists alerts_patient_created_idx
  on public.alerts(patient_id, created_at desc);
create index if not exists alerts_status_idx
  on public.alerts(status);
create index if not exists alerts_severity_idx
  on public.alerts(severity);

create or replace function public.update_alerts_updated_at()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

drop trigger if exists set_alerts_updated_at on public.alerts;
create trigger set_alerts_updated_at
before update on public.alerts
for each row
execute function public.update_alerts_updated_at();
```
